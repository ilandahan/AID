#!/bin/bash
# ============================================================
# QA Gate Hook
# ============================================================
# Triggered when a task is marked as complete.
# Checks if QA criteria exist and signals for QA review.
#
# Usage: qa-gate.sh <task-id>
# Exit codes:
#   0   - No QA criteria, skip review
#   100 - QA review required, spawn sub-agent
#   1   - Error
# ============================================================

set -e

# Configuration
QA_DIR=".aid/qa"
TASK_ID="${1:-}"

# ============================================================
# Validation
# ============================================================

if [ -z "$TASK_ID" ]; then
    echo "ERROR: No task ID provided"
    echo "Usage: qa-gate.sh <task-id>"
    exit 1
fi

QA_FILE="${QA_DIR}/${TASK_ID}.yaml"

# ============================================================
# Check if QA criteria exist
# ============================================================

if [ ! -f "$QA_FILE" ]; then
    echo "INFO: No QA criteria found for ${TASK_ID}"
    echo "INFO: Skipping QA gate (file not found: ${QA_FILE})"
    exit 0
fi

echo "INFO: QA criteria found for ${TASK_ID}"
echo "INFO: File: ${QA_FILE}"

# ============================================================
# Get modified files (for files_to_review)
# ============================================================

# Get files modified in the most recent commit or staged changes
if git diff --cached --name-only 2>/dev/null | grep -q .; then
    # Staged changes exist
    MODIFIED_FILES=$(git diff --cached --name-only)
    echo "INFO: Using staged files"
elif git diff --name-only HEAD~1 2>/dev/null | grep -q .; then
    # Use last commit
    MODIFIED_FILES=$(git diff --name-only HEAD~1)
    echo "INFO: Using files from last commit"
else
    # Fall back to all uncommitted changes
    MODIFIED_FILES=$(git status --porcelain | awk '{print $2}')
    echo "INFO: Using all uncommitted changes"
fi

# Filter to only code files (exclude generated, config, etc.)
CODE_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(ts|tsx|js|jsx|py|go|rs|java|rb|php|vue|svelte)$' || true)

if [ -z "$CODE_FILES" ]; then
    echo "WARN: No code files found in changes"
    echo "WARN: Proceeding with QA review anyway"
fi

echo "INFO: Files to review:"
echo "$CODE_FILES" | sed 's/^/  - /'

# ============================================================
# Update QA file with files_to_review
# ============================================================

# Note: In production, use yq or similar to properly update YAML
# For now, we'll append a comment with the files list

TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Create a temporary marker file that the QA agent can read
REVIEW_MARKER="${QA_DIR}/${TASK_ID}.review-pending"
cat > "$REVIEW_MARKER" << EOF
# QA Review Pending
# Generated by qa-gate.sh at ${TIMESTAMP}

task_id: ${TASK_ID}
criteria_file: ${QA_FILE}
triggered_at: ${TIMESTAMP}

files_to_review:
$(echo "$CODE_FILES" | sed 's/^/  - "/' | sed 's/$/"/')
EOF

echo "INFO: Created review marker: ${REVIEW_MARKER}"

# ============================================================
# Signal QA review required
# ============================================================

echo ""
echo "============================================================"
echo "QA_REVIEW_REQUIRED"
echo "============================================================"
echo "Task ID: ${TASK_ID}"
echo "Criteria: ${QA_FILE}"
echo "Files: $(echo "$CODE_FILES" | wc -l | tr -d ' ') code files"
echo "============================================================"
echo ""

# Exit code 100 signals that QA sub-agent should be spawned
exit 100
